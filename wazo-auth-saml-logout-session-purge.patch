diff --git a/integration_tests/suite/test_db_saml_pysaml2_cache.py b/integration_tests/suite/test_db_saml_pysaml2_cache.py
index 6e1171fb..1a246ba8 100644
--- a/integration_tests/suite/test_db_saml_pysaml2_cache.py
+++ b/integration_tests/suite/test_db_saml_pysaml2_cache.py
@@ -2,6 +2,7 @@
 # SPDX-License-Identifier: GPL-3.0-or-later
 
 import time
+from typing import Any
 
 from hamcrest import assert_that, is_
 from saml2.saml import NameID
@@ -21,15 +22,11 @@ class TestSAMLPysaml2Cache(base.DAOTestCase):
         format='urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress',
     )
 
-    @fixtures.db.saml_pysaml2_cache(NAME_ID)
-    def test_get_identity(self, fixture) -> None:
-        res, oldees = self._saml_pysaml2_cache_dao.get_identity(self.NAME_ID)
-        assert_that(res, is_(fixture['info']['ava']))
-        assert_that(oldees, is_([]))
+    YEAR_2000: int = 946684800
 
-    def test_set(self) -> None:
-        entry = {
-            'name_id': self.NAME_ID,
+    def _get_entry(self, name_id: NameID) -> dict[str, Any]:
+        return {
+            'name_id': name_id,
             'entity_id': 'https://test.idp.com/saml2/idp/id-1',
             'info': {
                 'ava': {
@@ -52,6 +49,23 @@ class TestSAMLPysaml2Cache(base.DAOTestCase):
             'not_on_or_after': int(time.time()) + 3600,
         }
 
+    @fixtures.db.saml_pysaml2_cache(NAME_ID)
+    def test_get_identity(self, fixture) -> None:
+        res, oldees = self._saml_pysaml2_cache_dao.get_identity(self.NAME_ID)
+        assert_that(res, is_(fixture['info']['ava']))
+        assert_that(oldees, is_([]))
+
+    def test_set(self) -> None:
+        entry = self._get_entry(self.NAME_ID)
+        self._saml_pysaml2_cache_dao.set(**entry)
+        res, _ = self._saml_pysaml2_cache_dao.get_identity(self.NAME_ID)
+
+        assert_that(res, is_(entry['info']['ava']))
+
+    @fixtures.db.saml_pysaml2_cache(NAME_ID, not_on_or_after=YEAR_2000)
+    def test_set_over_existing(self, _) -> None:
+        entry = self._get_entry(self.NAME_ID)
+
         self._saml_pysaml2_cache_dao.set(**entry)
         res, _ = self._saml_pysaml2_cache_dao.get_identity(self.NAME_ID)
 
diff --git a/integration_tests/suite/test_db_saml_session.py b/integration_tests/suite/test_db_saml_session.py
index 4a36a825..e733281a 100644
--- a/integration_tests/suite/test_db_saml_session.py
+++ b/integration_tests/suite/test_db_saml_session.py
@@ -115,3 +115,5 @@ class TestSAMLSessionDAO(base.DAOTestCase):
             calling(self._saml_session_dao.delete).with_args(REQUEST_ID),
             not_(raises(Exception)),
         )
+
+        assert_that(self._saml_session_dao.list(), is_([]))
diff --git a/tox.ini b/tox.ini
index dc5134e4..eb270f08 100644
--- a/tox.ini
+++ b/tox.ini
@@ -30,7 +30,7 @@ pass_env =
     WAZO_TEST_NO_DOCKER_COMPOSE_PULL
     WAZO_TEST_PROFILING_DIR
 commands =
-    make test-setup
+    #make test-setup
     pytest {posargs:suite/}
 allowlist_externals =
     make
diff --git a/wazo_auth/config.py b/wazo_auth/config.py
index 1f08280e..0d6648f8 100644
--- a/wazo_auth/config.py
+++ b/wazo_auth/config.py
@@ -127,7 +127,7 @@ _DEFAULT_CONFIG = {
         'domains': {},
         'acs_url_template': 'https://{{STACK_URL}}/api/auth/0.1/saml/acs',
         'saml_login_timeout_seconds': 600,
-        'saml_session_lifetime_seconds': 86400,
+        'saml_session_lifetime_seconds': 604800,
         'xmlsec_binary': '/usr/bin/xmlsec1',
         'key_file': '/var/lib/wazo-auth/saml/server.key',
         'cert_file': '/var/lib/wazo-auth/saml/server.crt',
diff --git a/wazo_auth/database/queries/__init__.py b/wazo_auth/database/queries/__init__.py
index a8da4416..2ae84298 100644
--- a/wazo_auth/database/queries/__init__.py
+++ b/wazo_auth/database/queries/__init__.py
@@ -10,6 +10,7 @@ from .ldap_config import LDAPConfigDAO
 from .policy import PolicyDAO
 from .refresh_token import RefreshTokenDAO
 from .saml_config import SAMLConfigDAO
+from .saml_pysaml2_cache import SAMLPysaml2CacheDAO
 from .saml_session import SAMLSessionDAO
 from .session import SessionDAO
 from .tenant import TenantDAO
@@ -30,6 +31,7 @@ class DAO:
         refresh_token,
         saml_config,
         saml_session,
+        saml_pysaml2_cache,
         session,
         tenant,
         token,
@@ -45,6 +47,7 @@ class DAO:
         self.refresh_token = refresh_token
         self.saml_config = saml_config
         self.saml_session = saml_session
+        self.saml_pysaml2_cache = saml_pysaml2_cache
         self.session = session
         self.tenant = tenant
         self.token = token
@@ -63,6 +66,7 @@ class DAO:
             refresh_token=RefreshTokenDAO(),
             saml_config=SAMLConfigDAO(),
             saml_session=SAMLSessionDAO(),
+            saml_pysaml2_cache=SAMLPysaml2CacheDAO(),
             session=SessionDAO(),
             tenant=TenantDAO(),
             token=TokenDAO(),
diff --git a/wazo_auth/database/queries/saml_pysaml2_cache.py b/wazo_auth/database/queries/saml_pysaml2_cache.py
index c4831f0b..8efedad1 100644
--- a/wazo_auth/database/queries/saml_pysaml2_cache.py
+++ b/wazo_auth/database/queries/saml_pysaml2_cache.py
@@ -24,18 +24,26 @@ logger: logging.Logger = logging.getLogger(__name__)
 class SAMLPysaml2CacheDAO(filters.FilterMixin, BaseDAO):
     search_filter: filters.SearchFilter = filters.saml_pysaml2_cache_search_filter
 
+    def get_expired(self, expiration_ts: int) -> list[SAMLPysaml2Cache]:
+        return (
+            self.session.query(SAMLPysaml2Cache)
+            .filter(SAMLPysaml2Cache.not_on_or_after < expiration_ts)
+            .all()
+        )
+
     def _search(self, **kwargs):
         search_filter = self.new_search_filter(**kwargs)
         return self.session.query(SAMLPysaml2Cache).filter(search_filter).all()
 
-    def delete(self, name_id: NameID) -> None:
-        filter_ = SAMLPysaml2Cache.name_id == code(name_id)
-        self.session.query(SAMLPysaml2Cache).filter(filter_).delete(
-            synchronize_session=False
-        )
-        self.session.flush()
+    def delete_encoded(self, name_id: str) -> None:
+        filter_ = SAMLPysaml2Cache.name_id == name_id
+        self.session.query(SAMLPysaml2Cache).filter(filter_).delete()
+        self.session.commit()
         logger.debug("Deleted from pysaml cache %s", name_id)
 
+    def delete(self, name_id: NameID) -> None:
+        self.delete_encoded(code(name_id))
+
     def get_identity(
         self,
         name_id: NameID,
@@ -109,7 +117,7 @@ class SAMLPysaml2CacheDAO(filters.FilterMixin, BaseDAO):
 
         cni = code(name_id)
 
-        if self.get(name_id, entity_id):
+        if self.get(name_id, entity_id, False):
             search_filter = self.new_search_filter(name_id=cni, entity_id=entity_id)
             data = {
                 'name_id': cni,
diff --git a/wazo_auth/database/queries/saml_session.py b/wazo_auth/database/queries/saml_session.py
index f45532ed..1a10e71f 100644
--- a/wazo_auth/database/queries/saml_session.py
+++ b/wazo_auth/database/queries/saml_session.py
@@ -111,7 +111,5 @@ class SAMLSessionDAO(filters.FilterMixin, BaseDAO):
 
     def delete(self, request_id) -> None:
         filter_ = SAMLSession.request_id == request_id
-        self.session.query(SAMLSession).filter(filter_).delete(
-            synchronize_session=False
-        )
-        self.session.flush()
+        self.session.query(SAMLSession).filter(filter_).delete()
+        self.session.commit()
diff --git a/wazo_auth/plugins/http/tokens/http.py b/wazo_auth/plugins/http/tokens/http.py
index f634d02d..c7503340 100644
--- a/wazo_auth/plugins/http/tokens/http.py
+++ b/wazo_auth/plugins/http/tokens/http.py
@@ -225,7 +225,6 @@ class Tokens(BaseResource):
             self._saml_service.update_refresh_token(
                 token.refresh_token, args.get('saml_session_id')
             )
-            self._saml_service.invalidate_saml_session_id(args.get('saml_session_id'))
 
         return {'data': token.to_dict()}, 200
 
diff --git a/wazo_auth/services/authentication.py b/wazo_auth/services/authentication.py
index 93202485..9d8a1704 100644
--- a/wazo_auth/services/authentication.py
+++ b/wazo_auth/services/authentication.py
@@ -80,6 +80,8 @@ class AuthenticationService:
         if not saml_login:
             raise NoMatchingSAMLSession(saml_session_id)
 
+        self._saml_service.invalidate_saml_session_id(saml_session_id)
+
         if (
             authorized_authentication_method := self._authorized_authentication_method(
                 saml_login
diff --git a/wazo_auth/services/saml.py b/wazo_auth/services/saml.py
index 4861427b..ad16a864 100644
--- a/wazo_auth/services/saml.py
+++ b/wazo_auth/services/saml.py
@@ -366,10 +366,7 @@ class SAMLService(BaseService):
     def invalidate_saml_session_id(self, saml_session_id: str) -> str | None:
         logger.debug('sessions %s', self._dao.saml_session.list())
         for reqid, session in self._dao.saml_session.list(session_id=saml_session_id):
-            update: dict[str, None] = {
-                'session_id': 'token-already-used',
-                'login': None,
-            }
+            update: dict[str, None] = {'session_id': 'token-already-used'}
             self._dao.saml_session.update(reqid, **update)
             return
         raise exceptions.SAMLProcessingError(
@@ -381,23 +378,34 @@ class SAMLService(BaseService):
             update = {'refresh_token_uuid': refresh_token}
             self._dao.saml_session.update(session_data.request_id, **update)
 
-    def clean_pending_requests(self, maybe_now: datetime | None = None) -> None:
-        now: datetime = maybe_now or datetime.now(timezone.utc)
+    def _clean_saml_sessions(self, now: datetime) -> None:
         for item in self._dao.saml_session.list():
-            expire_at: datetime = (
-                item.auth_context.start_time + self._saml_session_lifetime
-            )
-            if now > expire_at:
-                logger.debug("Removing SAML context: %s", item)
+            context: SamlAuthContext = item.auth_context
+            expire_at: datetime = context.start_time + self._saml_session_lifetime
+            if (
+                now > expire_at
+                and context.saml_session_id == 'token_already_used'
+                and context.refresh_token_uuid is None
+            ):
+                logger.debug('Deleting used SAML session: %s', item)
                 self._dao.saml_session.delete(item.request_id)
-                return
-            if item.auth_context.saml_session_id != 'token_already_used':
-                invalidate_at: datetime = (
-                    item.auth_context.start_time + self._saml_login_timeout
-                )
-                if now > invalidate_at:
-                    logger.debug('Deleting SAML login session on timeout: %s', item)
-                    self._dao.saml_session.delete(item.request_id)
+            elif now > expire_at and context.saml_session_id != 'token_already_used':
+                logger.debug("Deleting SAML session on timeout: %s", item)
+                self._dao.saml_session.delete(item.request_id)
+
+    def _clean_pysaml2_sessions(self, now: datetime) -> None:
+        session_expired: datetime = (
+            datetime.now(tz=timezone.utc) - self._saml_session_lifetime
+        )
+        session_expired_timestamp: int = int(round(session_expired.timestamp()))
+        for item in self._dao.saml_pysaml2_cache.get_expired(session_expired_timestamp):
+            logger.debug("Deleting from pysaml2 cache: %s", item.name_id)
+            self._dao.saml_pysaml2_cache.delete_encoded(item.name_id)
+
+    def clean_pending_requests(self, maybe_now: datetime | None = None) -> None:
+        now: datetime = maybe_now or datetime.now(timezone.utc)
+        self._clean_saml_sessions(now)
+        self._clean_pysaml2_sessions(now)
 
     def process_logout_request(self, token):
         logger.debug(
diff --git a/wazo_auth/services/tests/test_authentication.py b/wazo_auth/services/tests/test_authentication.py
index a51aca5b..327aba94 100644
--- a/wazo_auth/services/tests/test_authentication.py
+++ b/wazo_auth/services/tests/test_authentication.py
@@ -150,6 +150,9 @@ class TestAuthenticationService(TestCase):
 
         assert_that(result, contains_exactly(self.wazo_user_backend, s.login))
         assert_that(args, has_entries(login=s.login))
+        self.saml_service.invalidate_saml_session_id.assert_called_once_with(
+            s.saml_session_id
+        )
 
     def test_verify_auth_saml_not_authorized(self):
         self.saml_service.get_user_login.return_value = s.login
diff --git a/wazo_auth/services/tests/test_saml.py b/wazo_auth/services/tests/test_saml.py
index 1349c29f..548decac 100644
--- a/wazo_auth/services/tests/test_saml.py
+++ b/wazo_auth/services/tests/test_saml.py
@@ -12,6 +12,7 @@ from saml2.response import VerificationError
 from wazo_auth import exceptions
 from wazo_auth.config import _DEFAULT_CONFIG
 from wazo_auth.database.queries import DAO
+from wazo_auth.database.queries.saml_pysaml2_cache import SAMLPysaml2CacheDAO
 from wazo_auth.database.queries.saml_session import SAMLSessionDAO
 from wazo_auth.services.tenant import TenantService
 
@@ -26,6 +27,7 @@ class TestSAMLService(TestCase):
         self.tenant_service_mock = Mock(TenantService)
         self.dao_mock = Mock(DAO)
         self.dao_mock.saml_session = Mock(SAMLSessionDAO)
+        self.dao_mock.saml_pysaml2_cache = Mock(SAMLPysaml2CacheDAO)
         self.service = SAMLService(self.config, self.tenant_service_mock, self.dao_mock)
 
     def _get_auth_context(
@@ -50,6 +52,8 @@ class TestSAMLService(TestCase):
             SamlSessionItem('id2', pending),
         ]
 
+        self.dao_mock.saml_pysaml2_cache.get_expired.return_value = []
+
         now: datetime = datetime.fromisoformat('2000-01-02 00:00:01+00:00')
         self.service.clean_pending_requests(now)
 
@@ -68,6 +72,8 @@ class TestSAMLService(TestCase):
             SamlSessionItem('id2', pending),
         ]
 
+        self.dao_mock.saml_pysaml2_cache.get_expired.return_value = []
+
         now: datetime = datetime.fromisoformat('2000-01-01 00:00:11+00:00')
         self.service.clean_pending_requests(now)
 
@@ -288,10 +294,11 @@ class TestSAMLService(TestCase):
         pending_session = SamlSessionItem('req_id', saml_context)
 
         self.dao_mock.saml_session.list.return_value = [pending_session]
+        self.dao_mock.saml_pysaml2_cache.get_expired.return_value = []
 
         self.service.invalidate_saml_session_id(saml_context.saml_session_id)
 
-        update: dict[str, str] = {'session_id': 'token-already-used', 'login': None}
+        update: dict[str, str] = {'session_id': 'token-already-used'}
         self.dao_mock.saml_session.update.assert_called_once_with(
             pending_session.request_id, **update
         )
diff --git a/wazo_auth/tests/test_services.py b/wazo_auth/tests/test_services.py
index e5b43e9a..37cb2023 100644
--- a/wazo_auth/tests/test_services.py
+++ b/wazo_auth/tests/test_services.py
@@ -31,6 +31,7 @@ from ..database.queries import (
     policy,
     refresh_token,
     saml_config,
+    saml_pysaml2_cache,
     saml_session,
     session,
     tenant,
@@ -54,6 +55,7 @@ class BaseServiceTestCase(TestCase):
         self.refresh_token_dao = Mock(refresh_token.RefreshTokenDAO)
         self.saml_config_dao = Mock(saml_config.SAMLConfigDAO)
         self.saml_session_dao = Mock(saml_session.SAMLSessionDAO)
+        self.saml_pysaml2_cache = Mock(saml_pysaml2_cache.SAMLPysaml2CacheDAO)
         self.session_dao = Mock(session.SessionDAO)
         self.tenant_dao = Mock(tenant.TenantDAO)
         self.token_dao = Mock(token.TokenDAO)
@@ -75,6 +77,7 @@ class BaseServiceTestCase(TestCase):
             refresh_token=self.refresh_token_dao,
             saml_config=self.saml_config_dao,
             saml_session=self.saml_session_dao,
+            saml_pysaml2_cache=self.saml_pysaml2_cache,
             session=self.session_dao,
             tenant=self.tenant_dao,
             token=self.token_dao,
